var w=(x,o,u)=>new Promise((S,g)=>{var l=s=>{try{i(u.next(s))}catch(a){g(a)}},t=s=>{try{i(u.throw(s))}catch(a){g(a)}},i=s=>s.done?S(s.value):Promise.resolve(s.value).then(l,t);i((u=u.apply(x,o)).next())});var p=({dbName:x,store:o,autoIncrement:u,keyPath:S,version:g,uint8Array:l})=>{let t,i,s;l&&(i=new TextEncoder,s=new TextDecoder);let a=()=>new Promise(n=>{if(t)n(void 0);else{let e=window.indexedDB.open(x,g);e.onerror=console.error,e.onsuccess=r=>{t||(t=r.target.result),n(void 0)},e.onupgradeneeded=function(r){t||(t=r.target.result),t.createObjectStore(o,{autoIncrement:u,keyPath:S})}}}),m=typeof window.indexedDB!="undefined";m||console.error("[nano-indexed] [Error] Your browser not have indexedDB.");let y={set:(n,e)=>w(void 0,null,function*(){if(!!m)return t||(yield a()),l&&(typeof e!="string"?e=i.encode(JSON.stringify(e)):e=i.encode(e)),new Promise(r=>{if(t.objectStoreNames.contains(o)){let c=t.transaction([o],"readwrite").objectStore(o),f=n?c.put(e,n):c.put(e);f.onerror=d=>{console.error(d),r(void 0)},f.onsuccess=r}else r(void 0)})}),update:(n,e)=>w(void 0,null,function*(){let r=yield y.get(n);if(!r)return yield y.set(n,e),e;let b=Object.assign(Object.assign({},r),e);return yield y.set(n,b),b}),get:n=>w(void 0,null,function*(){if(!!m)return t||(yield a()),new Promise(e=>{if(t.objectStoreNames.contains(o)){let c=t.transaction([o]).objectStore(o).get(n);c.onsuccess=function(f){let d=f.target.result;if(l){d=s.decode(d);try{d=JSON.parse(d)}catch(v){}}e(d)}}else e(void 0)})}),remove:n=>w(void 0,null,function*(){if(!!m)return t||(yield a()),new Promise(e=>{if(t.objectStoreNames.contains(o)){let c=t.transaction([o],"readwrite").objectStore(o).delete(n);c.onerror=f=>{console.error(f),e(void 0)},c.onsuccess=e}else e(void 0)})})};return y};export{p as NanoIndexed};
